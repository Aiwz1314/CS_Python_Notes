## Python 实现常见排序算法

>注：
1. 本文只包含内排序，只在计算机内存中进行进行排序的算法。当待排序数据太大，不能在内存中记录排序数据时需要访问外存，则为外排序。
2. 稳定的排序算法(原址排序)：排序后不会改变值相等的元素的相对位置，则为稳定的排序算法。
3. 本文中默认实现升序排序。
4. 时间复杂度以元素移动次数为基准。

### 写在前面的总结
排序算法分类：
----- | -----
特性   |   排序算法
不稳定的排序算法 | 选择，快速、堆、Shell
适合较大n的排序算法 | 快速、归并、堆、基数
比较次数与初始有序度无关的排序算法 | 选择、二路归并、基数
最佳、最差、平均情况下时间复杂度一样的排序算法 | 选择、归并、堆、Shell、基数

排序算法的时间复杂度：
![sort complexity]('images/sort_complexity')


***

### 插入排序
每个新元素与前面已排序的子序列进行比较，将其插入子序列中正确的位置。
1. 初始时，将第一个元素视为已排序的子序列，从第二个元素到末尾为未排序元素；
2. 遍历未排序元素，将其（每次标志为key）与已排序子序列中的值从后往前（从大到小）一一比较，将已排序子序列中所有比key大的数往后挪一位。直到遇到第一个比key小的元素，将key插入这个元素后。
3. 遍历完完成排序。

```python
def insertion_sort(nums):
    n = len(nums)
    for i in range(1, n):
        key = nums[i]
        j = i - 1
        while j >= 0 and nums[j] > key:
            nums[j + 1] = nums[j]
            j -= 1
        nums[j + 1] = key
```
1. **稳定性**：仅当排序子序列中的元素比key大时才将其后移，而相等时会将key插入这个元素后，因此是稳定的。
2. **时间复杂度**： 插入排序外层循环总会执行n-1次，完成遍历。内层循环的执行次数取决于序列的无序程度，序列中的“逆序对（与期望序列顺序相反的元素对）”的数目决定了内层循环中的交换次数。
	- 最佳情况：序列本身有序，元素不需要进行移动，会进行n-1次比较（外层循环的执行次数），此时为**O(n)**;
	- 最差情况：序列本身逆序，内层循环每次需要执行i次，i的累计和（1，2，3，...，n-1）约为(n^2)/2，此时为**O(n^2)**;
	- 平均情况：平均情况下有序子序列中有一半与将要进行比较的元素呈逆序对，时间复杂度约为(n^2)/4，此时为**O(n^2)**。
3. 适用于基本有序的序列。


### 冒泡排序
从后往前冒泡：列表前面部分为已排序序列，每次像泡泡一样，将未排序部分最小的元素依次交换到列表前已排序子序列的最后；  
从前往后冒泡：列表后面部分为已排序序列，每次像泡泡一样，将未排序部分最大的元素依次交换到列表后已排序子序列的最前面。

```python
def buble_sort(nums):
    n = len(nums)
    for i in range(0, n):
        for j in range(n - 1, i + 1, -1):
        	if nums[j] < nums[j - 1]:
        		nums[i], nums[j] = nums[j], nums[i]
```
1. 稳定性：仅当后一个元素比前一个元素小的时候才交换，因此当两元素相等时不会交换，保存相对位置不变，是稳定的。
2. 时间复杂度： 内层循环总会执行i次，i的累计和约为(n^2)/2，因此冒泡排序在最佳、平均、最差情况下的时间复杂度均为**O(n^2)**。

**改进版冒泡排序**：在内层循环中加一个标记，用于记录这一次循环中有没有进行交换，若此次循环中未进行交换，则说明整个序列已经有序，这时可以提前跳出循环。此时的最佳时间复杂度为**O(n)**，即有序序列进入一次内层循环就发现不需要交换，跳出循环，算法结束。
```python
def bubble_sort(nums):
    n = len(nums)
    for i in range(0, n):
        exchange_flag = True        # 标记是否进行了交换
        for j in range(n - 1, i + 1, -1):
            if nums[j] < nums[j - 1]:
                nums[i], nums[j] = nums[j], nums[i]
                exchange_flag = False
        if exchange_flag == True:    # 若未进行交换，退出循环
            break
```

### 选择排序
选择排序每次将第i小的元素放到位置i处，可以将其看作冒泡排序的改进，冒泡排序是每次将dii小的元素交换到位置i，选择排序是直接找出这个元素并插入位置i。
```python
def selection_sort(nums):
    n = len(nums)
    for i in range(0, n - 1):
        min_idx = i     # 记录第i小的元素下标
        for j in range(i + 1, n):
            if nums[j] < nums[min_idx]:
                min_idx = j
        nums[i], nums[min_idx] = nums[min_idx], nums[i]
```
1. 稳定性：寻找剩余元素中最小元素的部分是从前往后遍历，因此若两数相等，后面的一个最终会被视为当前最小并被放入排序子序列中，因此选择排序是不稳定的。
2. 时间复杂度：在任何情况下都会运行完两重循环，因此其最佳、平均和最差时间复杂度相等，均为**O(n^2)**。

### 归并排序

### 快速排序

### 堆排序

### Shell排序

### 基数排序

>参考：  
《数据结构与算法分析（C++版）（第三版）》
《算法导论（原书第三版）》